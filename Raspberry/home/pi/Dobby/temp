Main:
gint cnt = 0;

	/*************************/
	/* Initialisierungsphase */
	/*************************/

	// Bibliothek um GPIOs anzusprechen
	if (linInitialise() < 0) {
		printf("Initialisierung fehlgeschlagen!\n");
	}
	gpioSetMode(27, PI_OUTPUT); 		// Lampe weiss
	gpioSetMode(23, PI_OUTPUT); 		// Lampe rot
	gpioSetMode(24, PI_OUTPUT);		// Lampe gruen
	gpioSetMode(25, PI_OUTPUT);		// Lampe gelb
	//
	gpioWrite(25, 1);
	gpioWrite(27, 1);
	gpioDelay(2000);
	gpioWrite(24, 0);
	WebSocket_initialisierung(argc, argv);
	// Status für Websocket-Init wird in Funktion implementiert
	sens_init = Sensor_initialisierung();
	// Status für Sensor-Init wird in Funktion implementiert
	if (sens_init != 7) {
		gpioWrite(23, 1);
		gpioDelay(2000);
		gpioWrite(23, 0);
	}

	gpioWrite(25, 0);
	gpioWrite(27, 0);

	/*****************/
	/* Hauptschleife */
	/*****************/
	while (cnt >= 0 && !exit_loop) {
		gpioWrite(24, 1);
		if (sens_init == 7) {
			Sensor_routine();
		}

		cnt = libwebsocket_service(context, 10);// u.a. neue Verbindungen werden akzeptiert ; ggf. setzen des send_notification
		if (send_notification) {
			libwebsocket_callback_on_writable_all_protocol(&protocols[0]);
			send_notification = FALSE;
		}
		g_main_context_iteration(NULL, FALSE);
	}

	/* Abbruchroutine */
	out: if (context != NULL)
		libwebsocket_context_destroy(context);
	if (signal_id > 0)
		g_source_remove(signal_id);
	if (option_context != NULL)
		g_option_context_free(option_context);
	close(sockfd); 								// Close Sensor-Socket
#ifndef HAVE_SYSTEMD
	closelog();
#endif

	return exit_value;
	
	
	
	
	
	
	
	
	LIN.CPP
	
	/* ******************************************/
/* ******************************************/
/* Motor-Funktionen 			     		*/
/* ******************************************/
/* ******************************************/

#include <stdlib.h>
#include <stdarg.h>
#include <stdio.h>
#include <fcntl.h>
#include <termios.h>
#include <pigpio.h>
#include <lin.h>

	Lin::Lin(){
		if (gpioInitialise() < 0)
		{
			printf("[FAIL] PIGPIO Initialisierung fehlgeschlagen");
		}
		else
		{
			printf("[OK] PIGPIO Initialisierung ok");
		}
	}
	Lin::~Lin(){
		gpioTerminate();
		printf("[OK] PIGPIO beendet");
	}
};
/**
 *
 */
void Lin::initializeSend() {
	handle = serOpen("/dev/ttyAMA0", BAUDRATE, 0);

	if (0 > handle) {
		printf("[ERROR] UART open\n");
	} else {
		printf("[OK] UART open\n");
	}
}

/**
 *
 * @param id	Frame ID
 * @param data0 ID
 * @param data1	DB0
 * @param data2	DB1
 * @param data3	DB2
 * @param data4	DB3
 * @param data5	DB4
 * @param data6	DB5
 * @param data7	DB6
 * @param data8	DB7
 * @return 1 if the frame was set correctly, otherwise 0
 */
int Lin::setFrame(int id, int data0, int data1, int data2, int data3, int data4,
		int data5, int data6, int data7, int data8) {
	if (id == message) {
		messageFrame.frameContent[0] = data0;
		messageFrame.frameContent[1] = data1;
		messageFrame.frameContent[2] = data2;
		messageFrame.frameContent[3] = data3;
		messageFrame.frameContent[4] = data4;
		messageFrame.frameContent[5] = data5;
		messageFrame.frameContent[6] = data6;
		messageFrame.frameContent[7] = data7;
		messageFrame.frameContent[8] = data8;
		messageFrame.frameContent[9] = getChecksum(messageFrame.frameContent);
		return 1;
	}

	if (id == init) {
		initFrame.frameContent[0] = data0;
		initFrame.frameContent[1] = data1;
		initFrame.frameContent[2] = data2;
		initFrame.frameContent[3] = data3;
		initFrame.frameContent[4] = data4;
		initFrame.frameContent[5] = data5;
		initFrame.frameContent[6] = data6;
		initFrame.frameContent[7] = data7;
		initFrame.frameContent[8] = data8;
		initFrame.frameContent[9] = getChecksum(initFrame.frameContent);
		return 1;
	}

	if (id == activation) {
		activationFrame.frameContent[0] = data0;
		activationFrame.frameContent[1] = data1;
		activationFrame.frameContent[2] = data2;
		activationFrame.frameContent[3] = data3;
		activationFrame.frameContent[4] = data4;
		activationFrame.frameContent[5] = data5;
		activationFrame.frameContent[6] = data6;
		activationFrame.frameContent[7] = data7;
		activationFrame.frameContent[8] = data8;
		activationFrame.frameContent[9] = getChecksum(
				activationFrame.frameContent);
		return 1;
	}
	printf("Falsche oder unbekannte FrameID (%d)", id);
	return 0;
}
/**
 *
 * @param frame
 * @return
 */
int Lin::getChecksum(int frame[]) {
	int summe = 0;
	int i;

	for (i = 1; i < 9; i++) {
		summe += frame[i];
		if (summe > 255) {
			summe -= 255;
		}
	}
	return ~summe & 0xFF;
}

/**
 *
 */
void Lin::sendMessageFrame() {
	sendBreak();
	sendSyncByte();
	int i;
	for (i = 0; i < sizeof(messageFrame.frameContent); i++) {
		serWriteByte(handle, messageFrame.frameContent[i]);
	}
}

/**
 *
 */
void Lin::sendActivationFrame() {
	sendBreak();
	sendSyncByte();
	int i;
	for (i = 0; i < sizeof(activationFrame.frameContent); i++) {
		serWriteByte(handle, activationFrame.frameContent[i]);
	}
}

/**
 *
 */
void Lin::sendInitFrame() {
	sendBreak();
	sendSyncByte();
	int i;
	for (i = 0; i < sizeof(initFrame.frameContent); i++) {
		serWriteByte(handle, initFrame.frameContent[i]);
	}
}

/**
 *
 */
void Lin::sendBreak() {
	handle = serClose(handle);
	printf("[OK] UART Closed\n");
	gpioSetMode(14, PI_OUTPUT);
	gpioWrite(14, 0);
	printf("[OK] Set Output Low, wait 100ms\n");
	gpioSleep(PI_TIME_RELATIVE, 0, 680);  //Warte 680µs
	gpioWrite(14, 1);
	gpioSleep(PI_TIME_RELATIVE, 0, 20);  //Warte 680µs
	printf("[OK] Set Output High\n");
	gpioSetMode(14, PI_ALT0);
	handle = serOpen("/dev/ttyAMA0", BAUDRATE, 0);
}

/**
 *
 */
void Lin::sendWakeUp() {
	handle = serClose(handle);
	gpioSetMode(14, PI_OUTPUT);
	gpioWrite(14, 0);
	gpioSleep(PI_TIME_RELATIVE, 0, 70);  //Warte 1ms
	gpioWrite(14, 1);
	gpioSetMode(14, PI_ALT0);
	handle = serOpen("/dev/ttyAMA0", BAUDRATE, 0);
	gpioSleep(PI_TIME_RELATIVE, 0, 150000);
}

/**
 *
 */
void Lin::sendSyncByte() {
	serWriteByte(handle, 0x55);
}

/**
 *
 */
void Lin::setInitialContents() {
	messageFrame.id = message;
	activationFrame.id = activation;
	initFrame.id = init;
	setFrame(init, 0x3C, 0xA0, 0x02, 0x10, 0x84, 0xFF, 0xFF, 0xFF, 0xFF); //Checksum 0xC8
	setFrame(activation, 0x3C, 0xAA, 0x9F, 0x0E, 0x0D, 0x01, 0xFF, 0xFF, 0xFF); //Checksum 0x99
}

int Lin::linInitialise(){
	return gpioInitialise();
}

/**
 *
 * @param directionLeft
 * @param velocityLeft	value between 0 and 100 (0x64). The velocity of the left engine
 * @param directionRight
 * @param velocityRight value between 0 and 100 (0x64). The velocity of the right engine
 */
void Lin::startMotors(int directionLeft, int velocityLeft, int directionRight,
		int velocityRight) {
	setInitialContents();
	if (handle < 0) {
		initializeSend();
	}
	setFrame(message, 0x3C, 0x84, directionLeft, velocityLeft, 0x55, 0xA5,
			directionRight, velocityRight, 0xFF);
	sendWakeUp();
	gpioSleep(PI_TIME_RELATIVE, 0, 310000);  //Warte 310ms
	sendInitFrame();
	gpioSleep(PI_TIME_RELATIVE, 0, 50000);  //Warte 50ms
	sendActivationFrame();
	gpioSleep(PI_TIME_RELATIVE, 0, 50000);  //Warte 50ms
	sendMessageFrame();
	gpioSleep(PI_TIME_RELATIVE, 0, 50000);  //Warte 50ms
	delay(2000);
}

/**
 *
 */
void Lin::stopMotors() {
	if (handle < 0) {
		initializeSend();
	}
	setFrame(message, 0x3C, 0x84, 0xAA, 0x00, 0x55, 0xA5, 0xAA, 0x00, 0xFF); //Checksum 2B
	sendWakeUp();
	gpioSleep(PI_TIME_RELATIVE, 0, 310000);
	sendInitFrame();
	gpioSleep(PI_TIME_RELATIVE, 0, 50000);
	sendActivationFrame();
	gpioSleep(PI_TIME_RELATIVE, 0, 50000);
	sendMessageFrame();
	gpioSleep(PI_TIME_RELATIVE, 0, 50000);
	delay(2000);
}
	
	
	
LIN.H

#ifndef LIN_H
#define LIN_H

class Lin
{
public:
	Lin();
	~Lin();
	void startMotors(int directionLeft, int velocityLeft, int directionRight, int velocityRight);
	void stopMotors();
	void initialiseSend();
	int linInitialise();
private:
	int BAUDRATE = 19200;
	int handle = -1;

	enum {
		message = 1, activation = 2, init = 3
	};
	struct Frame{
		int id;
		int frameContent[10];
	};
	Frame initFrame;
	Frame messageFrame;
	Frame activationFrame;

	initFrame.id = init;
	activationFrame.id = activation;
	messageFrame.id = message;


	int setFrame(int id, int data0, int data1, int data2, int data3, int data4,
			int data5, int data6, int data7, int data8);
	int getChecksum(int frame[]);
	void sendMessageFrame();
	void sendActivationFrame();
	void sendInitFrame();
	void sendBreak();
	void sendWakeUp();
	void sendSyncByte();
	void setInitialContents();
};
#endif /* LIN_H */
